use serde::Deserialize;
use std::{collections::HashMap, fs::read_to_string, io, path::Path};

/// A parameter identifier
pub type Pid = String;

/// A SMILES string
pub type Smiles = String;

pub mod parameter_map;

#[macro_export]
macro_rules! die {
    ($($t:tt)*) => {{
        eprintln!($($t)*);
        std::process::exit(1);
    }};
}

/// A single row from a file loaded by [load_csv]
pub struct Record {
    /// the QCArchive record ID
    pub id: usize,
    pub value: f64,
}

/// Load a simple CSV file generated by
/// [ib](https://github.com/mattwthompson/ib) from `path`.
///
/// Skips one header line and returns the remaining lines as a sequence of
/// [Record]s
pub fn load_csv(path: impl AsRef<Path>) -> io::Result<Vec<Record>> {
    Ok(read_to_string(path)?
        .lines()
        .skip(1) // header
        .map(|s| {
            let sp: Vec<_> = s.split(',').map(str::trim).collect();
            assert_eq!(sp.len(), 2);
            Record {
                id: sp[0].parse().unwrap(),
                value: sp[1].parse().unwrap(),
            }
        })
        .collect())
}

/// A single entry in a [Dataset]
#[derive(Deserialize)]
pub struct Entry<T> {
    /// the QCArchive record ID
    pub record_id: T,

    /// the canonical SMILES string representing the molecule
    pub cmiles: String,
}

#[derive(Deserialize)]
pub struct Dataset<T> {
    pub entries: HashMap<String, Vec<Entry<T>>>,
}

/// Load a [Dataset] from `path` and return it as a map of record ID to SMILES.
///
/// This function loads directly from JSON without using any code specific to a
/// certain dataset type, allowing it to work for both
/// OptimizationResultCollections and TorsionDriveResultCollections.
pub fn load_dataset(
    path: impl AsRef<Path>,
) -> io::Result<HashMap<String, String>> {
    /// new datasets keep the record IDs as integers, not strings. if loading as
    /// a string fails, try again with usize
    fn inner<T: for<'a> Deserialize<'a> + Eq + std::hash::Hash>(
        path: impl AsRef<Path>,
    ) -> io::Result<HashMap<T, String>> {
        let ds: Dataset<T> = serde_json::from_str(&read_to_string(path)?)?;
        Ok(ds
            .entries
            .into_values()
            .flatten()
            .map(|rec| (rec.record_id, rec.cmiles))
            .collect())
    }
    let ret = match inner::<String>(&path) {
        Ok(ds) => ds,
        Err(_) => {
            let ds = inner::<usize>(&path)?;
            ds.into_iter().map(|(k, v)| (k.to_string(), v)).collect()
        }
    };
    Ok(ret)
}
